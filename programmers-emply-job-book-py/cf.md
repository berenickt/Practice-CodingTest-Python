# 1. readline() : 입력속도를 빠르게

- 프로그래머스는 입력값을 모두 주고, 기능만 구현하는 함수형태로 작성하지만,
- 백준같이 입력값을 받는 코드도 직접 구현해야 하는 경우가 있다.
- 이럴 떄는 sys 모듈의 readline()을 활용
  - 파이썬으로 값을 입력받을 떄 input()을 쓰면 되지만, 데이터가 많을 수록 효율이 떨어짐
  - 받은 문자열을 다시 쪼개더라도 readline() 함수를 사용해 빨리 읽어오는게 훨씬 효율적

```py
import sys
data = sys.stdin.readline()
```

---

# 2. 리스트 곱셈 : 초기화와 할당을 빠르게

- 기본적으로 배열(리스트)을 다룰 때는 동적으로 다루지만, 가끔 미리 할당해 놓은 고정 배열에다가 계산해야 할 떄가 있습니다.
- 이런 경우 리스트에 곱셈 연산을 하여 초기화와 할당을 동시에 진행 가능

```py
data = [0 for _ in range(1000)]
data2 = [0] * 1000
```

- data1의 경우 for문을 1,000번 반복해 리스트에 0을 집어넣기에 O(n)만큼 소모
- data2의 경우 [0]을 1,000번 반복하는 것이라 O(n) 시간으로 동일한 작업을 수행

---

# 3. 문자열 합치기 : "join()"을 쓰고 +는 사용하지 말기

다른 언어와 다르게 파이썬의 문자열은 내용을 변경할 수 없기 때문에 +로 합칠경우 각각의 문자열을 새 메모리에 복사해 새 문자열을 만들기에 사실상 시간 복잡도가 O(n^2)정도가 됩니다.

따라서 `.join()`을 사용해 문자열을 합쳐야 이런 계산과정을 거치지 않고 빠르게 합칠 수 있습니다.

---

# 4. 조건문 연산 줄이기 : 짧은 것부터 먼저 계산하기

- if 조건문에서 다중 조건을 사용하면, 두 조건 중 빨리 실행되는 쪽을 앞쪽에 배치하는 것이 유리
- and 연산을 할 떄, 앞의 연산결과가 false라면, 뒤의 연산은 실행하지 않고 넘어가며, or 또한 앞의 연산 결과가 true라면 뒤의 연산을 실행하지 않습니다.

---

# 5. 슬라이싱 : [이상, 미만, 간격]

리스트, 튜플, 문자열과 같은 잘형에 범위를 지정해 일부분만 추출하는 기능

문자열 역시 슬라이싱 기능을 사용할 수 있습니다.

```py
print('Python is aesome'[3::2]) # hni eoe
```

다음과 같이 2차원, 3차원 배열도 가능합니다.

```py
data = [[(0, 1), (2, 3), (4, 5)], [(6, 7), (8, 9), (0, 1)]]
print(data[1:][0][::2]) # [(6, 7), (0, 1)]
```

---

# 6. 표준 라이브러리 활용하기 : 속도와 안전성 모두 잡기

단, 많은 코딩 테스트에서 외부 라이브러리를 사용하지 못하게 하므로 표준 라이브러리는 적극적으로 사용하되 외부 라이브러리는 사용하지 않는 방향으로 진행하세요.

다음은 자주 사용하는 자료 구조나, 계산할 때 바로 쓸 수 있는 라이브러리입니다. 여기서는 간단히 소개만 하고, 각각을 사용하는 장에서 자세히 설명할 예정임

1. `heapq`: 이진 트리 기반의 최소 힙 자료 구조
   - 항상 정렬된 상태로 값의 추가/삭제가 이루어집니다.
   - 우선순위 큐나 최단 거리 알고리즘을 구현할 때 많이 사용됩니다.
2. `collections` :
   - 연속되는 자료를 가지고 있는 자료형에서 동일한 원소가 몇 개 있는지 확인 가능한 counter가 있기 때문에 해시 문제를 풀 때 유용
   - 추가로 덱(dequeue) 자료 구조를 구현하는 데 사용하는 deque도 있음
3. `itertools`: 경우의 수 문제에 사용
   - 순열(permutations), 조합(combinations), 중복순열(permutations_with_replacement), 중복조합(combinations_with_replacement) 등에 사용.
4. `math`: 복잡한 수학 연산을 대신하는 라이브러리
   1. 최대공약수, 최소공배수, 팩토리얼, 제곱근, 로그 등을 계산
   2. 파이, 자연상수와 같은 상수도 존재해 수학 문제가 나온다면 이것만 있으면 됨
5. `bisect`: 이진 탐색 기능을 제공
   - 정렬된 데이터가 필요하며,
   - 특정 범위 안에 원소가 있는지 검사하거나 몇 개가 존재하는지 확인하는 데 유용

---

# 7. 리스트 컴프리헨션 vs 제너레이터: 편의성과 효율의 대결

리스트에 1부터 10까지 데이터를 넣는다면 for 문을 사용한 기본 형태는 다음과 같습니다

```py
data1 = []
data2 = []

# range(이상, 미만, 간격) : 리스트 슬라이싱과 유사
for i in range(1, 11):  # 1~10
    data1.append(i)

# "이상"을 생략해서 1개의 파라미터만 쓰면, 0부터 시작해 "미만"만 적용
for i in range(11):  # 0~10
    data2.append(i)


print(data1)  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(data2)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

위 코드를 한 줄로 줄이려면 컴프리헨션(comprehension)을 사용하면 됩니다.

```py
[i for i in range(1, 11)]
```

여기서는 리스트를 주로 다루기 때문에 리스트 컴프리헨션이라고 부르지만 tuple, set, dict 같은 자료형에서도 모두 사용 가능

## 7.1 리스트 컴프리헨션 문법

```py
[(변수 표현식) for (사용할 변수) in (순회 가능한 연속적인 데이터)]
```

바로 앞의 코드에서 짝수만 뽑고 싶다면 간단하게 뒤에 if 문을 추가하면 됩니다

```py
[i for i in range(11) if i % 2 == 0]
```

또한, if 문 뒤에 다시 if 문을 중첩할 수도 있습니다. 이때 if 문은 and로 취급합니다(직접적으로 and를 넣으면 오류가 발생합니다. 마찬가지로 or도 사용할 수 없습니다). 이 코드에서 짝수와 5의 배수를 동시에 만족하는 숫자만 필요하다고 하면 다음 코드처럼 작성하면 됩니다.

```py
[i for i in range(11) if i % 2 == 0 if i % 5 == 0]
```

> 💡 cf. 사용하기 간편하고 많은 것을 할 수 있다고 해도, 너무 심하게 줄이는 것은 좋지 않습니다. 앞서 말했지만 이해하지 못하는 코드는 오히려 큰 문제를 일으키는 도화선이 됩니다.

그러나 컴프리헨션은 데이터가 10만 개나 100만 개 있을 때 이 데이터를 모두 생성하기 때문에 크게 신경 쓸 필요가 없다고 했던 공간 복잡도를 고려하게 하는 원인이 되기도 합니다. 편리한 기능은 대부분 이렇게 공간 복잡도가 커지는 경우가 많습니다. 따라서 이에 대한 대응책으로 제너레이터(generator)를 사용합니다.

제너레이터는 연속 가능한(iterator) 자료형을 반환하는 함수로, 실행 중 yield를 만나면 값을 반환하고 더 이상 진행할 수 없는 상태가 아니라면 next()가 호출되기 전까지 대기합니다. 즉, 한 번에 모두 실행하고 그에 대한 결괏값을 반환하는 것이 아니라, 함수가 실행되었다가 다음 next()를 대기하면서 실행이 멈춥니다. 제너레이터를 만드는 방법은 두 가지로, 함수를 정의할 때 return 대신 yield 문구를 집어넣거나, 컴프리헨션 문구를 소괄호로 감싸주는 방식으로 표현식을 생성합니다. 예제에서는 직접 제너레이터를 생성하지 않고 후자의 방법으로 생성하여 설명하겠습니다.

1부터 10까지의 데이터를 선언하는 앞의 코드를 제너레이터로 바꾸려면 컴프리헨션을 괄호로 감싸면 됩니다.

```py
(i for i in range(11))
```

이 함수는 한 번에 1부터 10까지 진행하지 않고, 직접 next()를 호출해야 1, 2, 3의 값이 반환됩니다. 이때 이전 값은 갖지 않으며, 필요하다면 따로 list() 같은 함수를 통해 실행되는 값을 저장해야 합니다.

제너레이터의 장점은 함수가 실행할 것이 매우 많아도 메모리는 항상 고정된 값을 지닌다는 점을 꼽을 수 있습니다. 만약 100만 개의 데이터를 제곱해서 더해야 한다면, 리스트 컴프리헨션과 제너레이터의 성능은 얼마나 차이가 날까요?

실행 시간은 거의 비슷하지만(둘 다 O(n) 시간이 소요되며, 출력 결과를 보면 제너레이터가 더 빠르지만 실행 환경에 따라 달라질 수 있습니다) 메모리 사용량은 큰 차이를 보입니다.

컴프리헨션 방식은 8MB를 사용했으나 제너레이터는 단 112Byte만 사용합니다. 이렇게 메모리를 많이 절약할 수 있는 장점이 있지만, 반대로 실행하기 전까지는 데이터를 갖지 않으므로 결과 정보를 저장하려면 실행 비용 + 변수를 사용해야 하는 단점도 있습니다.

결국 리스트 컴프리헨션과 제너레이터를 언제 사용할 것인지는 여러분의 판단입니다. 컴프리헨션을 제너레이터로 대체하여 사용하는 것이 가능하고 여러 장점을 가질 수 있더라도 절대적인 대체제가 아니라는 점을 염두에 두기 바랍니다.
