"""📍 dynamic_programming(다이나믹 프로그래밍)
-> 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘

다이나믹 프로그래밍은 메모리 공간을 약간 더 사용해 
연산 속도를 비약적으로 증가시키는 방법으로, 
동적 계획법이라고도 표현한다.

동적계획법으로 해결 할 수 있는 대표적인 예제는 피보나치수열이다.
피보나치 수열 : 이전 두 항의 합을 현재의 항으로 설정하는 수열
수학자들은 점화식을 사용해 수열의 항이 이어지는 형태를 간결하게 표현한다.

점화식 : 인접한 항들 사이의 관계식을 의미
e.g. 수열 |a_n]이 있을 떄 수열에서 각 항을 a_n이라 부른다고 가정하자.
점화식을 통해 동적계획법으로 코드를 작성할 수 있다.

다음 피보나치 수열의 점화식을 살펴보자.
> a(n) = a(n-1) + a(n-2), a1 = 1, a2 = 1

이를 해석하면 다음과 같다.
1. n번째 피보나치 수 = (n-1)번째 피보나치 수 + (n-2)번째 피보나치 수
2. 단, 1, 2번째 피보나치 수 = 1
"""


# 피보나치 함수를 재귀 함수로 구현
# 수학적 점화식을 프로그래밍으로 작성하면 다음과 같이 작성할 수 있다.
def fibo(x):
    if x == 0 or x == 1:
        return 1
    return fibo(x - 1) + fibo(x - 2)


print(fibo(4))
"""
그런데, 이런식으로 소스코드로 작성하면 심각한 문제가 생길 수 있다. 
바로 f(n) 함수에서 n이 커질수록 수행 시간이 기하급수적으로 늘어나기 때문이다.
이 소스코드의 시간 복잡도를 말하면 O(2^n)의 지수시간이 소요된다고 표현한다.

만약, n = 30이라고 가정하면 약 10억가량의 연산을 수행해야하는데, 이는 매우 비효율적이다.
이처럼, 점화식을 재귀함수를 사용해 만들 수는 있지만, 단순히 매번 계산하도록하면 문제를 효율적으로 풀 수 없다.
이러한 문제는, 다이나믹 프로그래밍을 사용하면 효율적으로 해결 할 수 있는데, 다음의 조건이 필요함을 인지하자

큰 문제를 작은 문제로 나눌 수 있다.
작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
피보나치 문제는 이러한 조건을 만족하는 대표적인 문제이다.
"""
