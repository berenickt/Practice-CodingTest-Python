# 📚 https://www.acmicpc.net/problem/1463
"""
정수 X가 주어질때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.
1) X가 5로 나누어떨어지면, 5로 나눈다.
2) X가 3으로 나누어 떨어지면, 3으로 나눈다.
3) X가 2로 나누어 떨어지면, 2로 나눈다.
4) X에서 1을 뺀다.

정수 X가 주어졌을때, 연산 4개를 적절히 사용해서 1을 만들려고 한다.
연산을 사용하는 횟수의 최솟값을 출력하시오.

e.g. 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.
26 - 1 = 25
25 / 5 = 5
5 / 5 = 1

input #1 정수 X이 주어진다. (1<=X<=1,000,000)
26

output #1 연산을 하는 횟수의 최솟값
3
"""

"""
피보나치 수열 문제를 도식화했던 것처럼 문제를 풀기 전에 
함수가 호출되는 과정을 직접 그림으로 그려보면 이해하는데 도움이 된다.

점화식은 다음과 같다.
> a(i) = min(a(i-1), a(i-2), a(i-5)) + 1
> 점화식 끝에 1을 더해주는 이유는 함수의 호출 횟수를 구해야하기 때문이다.

실제 코드로 구현 할 때는 1을 빼는 연산을 제외하고는 
해당 수로 나누어떨어질 때 한해서만 점화식을 적용 할 수 있다.
두 수 중 단순히 더 작은수를 구할 때는 min() 함수를 이용하자.

이 문제를 풀때 사실 답안 예시를 보고도 이해가 되지않았다. 
그래서 다른 사람들은 어떻게 풀었는지 검색해봤는데,
빈 리스트(values)를 선언하고 거기에 추가하는 방식이다.
"""
# 사용자로부터 정수 n을 입력받음
n = int(input())

# 최소 연산 횟수를 저장하기 위한 배열 d를 초기화
d = [0] * (n + 1)

# 1은 이미 1로 만들었으므로 연산 횟수는 0
d[1] = 0

# 2부터 n까지 반복하며 최소 연산 횟수를 계산
for i in range(2, n + 1):
    # 현재 숫자 i를 1을 빼는 연산으로 초기화
    d[i] = d[i - 1] + 1

    # i가 2로 나누어 떨어지고, 2로 나눈 결과의 연산 횟수가 더 작다면 업데이트
    if i % 2 == 0 and d[i] > d[i // 2] + 1:
        d[i] = d[i // 2] + 1

    # i가 3으로 나누어 떨어지고, 3으로 나눈 결과의 연산 횟수가 더 작다면 업데이트
    if i % 3 == 0 and d[i] > d[i // 3] + 1:
        d[i] = d[i // 3] + 1

# 최소 연산 횟수를 출력
print(d[n])
