"""📍  BFS(Breadth-First-Search)
BFS 알고리즘은 너비 우선탐색이라는 의미를 가진다. 
쉽게말해, 가까운 노드부터 탐색하는 알고리즘이다.

DFS와 BFS 알고리즘의 주요 차이점은 다음과 같다.
1. DFS: 최대한 멀리있는 노드를 우선으로 탐색하는 방식
2. BFS: 최대한 가까이있는 노드를 우선으로 탐색하는 방식

또한, BFS는 스택(Stack)방식을 사용하는 DFS와 다르게 
선입선출방식인 큐(Queue) 자료구조를 이용하는것이 정석이다.
알고리즘의 동작방식은 다음과 같다.

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 
    방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

deque 라이브러리를 사용하는 것이 좋으며 탐색 수행에 O(n) 시간복잡도가 소요된다.
일반적인 경우 실제 수행시간은 DFS보다 좋은편이다.
재귀함수로 DFS를 구현하면, 컴퓨터 시스템 특성상 실제 수행시간은 느려질 수 있다.
따라서 스택을 이용해 시간복잡도를 완화하는 기술이 필요하지만,
코테에서는 보통 DFS보다는 BFS 구현이 좀 더 빠르게 동작한다는 정도로 기억하자.
"""
from collections import deque


# BFS 메서드 정의
def bfs(graph, start, visited):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    # 현재 노드를 방문 처리
    visited[start] = True

    # 큐가 빌 떄까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아 출력
        v = queue.popleft()
        # 현재 방문한 노드 출력
        print(v, end=" ")
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True


# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [[], [2, 3, 8], [1, 7], [1, 4, 5], [3, 5], [3, 4], [7], [2, 6, 8], [1, 7]]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 BFS 함수 호출
bfs(graph, 1, visited)
# 👉🏽 2 3 8 7 4 5 6

"""
아래는 코드가 실행되는 동안 visited가 어떻게 변하는지에 대한 설명입니다.

1. 초기 상태: 
- visited = [F, F, F, F, F, F, F, F, F]

2. 첫 번째 노드(1) 방문 후: 
- visited = [F, T, F, F, F, F, F, F, F]
- 출력: 1

3. 노드 1과 연결된 노드(2, 3, 8) 방문 후: 
- visited = [F, T, T, T, F, F, F, F, T]
- 출력: 1 2 3 8

4. 노드 2와 연결된 노드(7) 방문 후: 
- visited = [F, T, T, T, F, F, F, T, T]
- 출력: 1 2 3 8 7

5. 노드 3과 연결된 노드(4, 5) 방문 후: 
- visited = [F, T, T, T, T, T, F, T, T]
- 출력: 1 2 3 8 7 4 5

6. 노드 8과 연결된 노드(6) 방문 후: 
- visited = [F, T, T, T, T, T, T, T, T]
- 출력: 1 2 3 8 7 4 5 6

따라서, 모든 노드가 방문되면 visited 리스트는 모두 True로 채워집니다.
"""

"""
앞서 DFS와 BFS를 설명하는데, 전형적인 그래프 그림을 이용했는데, 
1차원 배열이나 2차원 배열 또한 그래프 형태로 생각하면 수월하게 문제를 풀 수 있다.
특히, DFS와 BFS 문제 유형이 그러하다.

코딩 테스트 중 2차원 배열에서의 탐색 문제를 만나면, 
이렇게 그래프 형태로 바꿔서 생각하면 풀이 방법을 조금 더 쉽게 떠올릴 수 있다.
"""
