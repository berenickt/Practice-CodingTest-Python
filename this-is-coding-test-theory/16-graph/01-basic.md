지금까지 코딩 테스트에서 출제 비중이 높은 알고리즘 유형들을 다뤄보았다.
기타 그래프 이론은 지금까지 다루지 않은 그래프 알고리즘을 추가로 다뤄보자.
이전에 배웠던 DFS / BFS와 최단 경로에서 다룬 내용은 모두 그래프 알고리즘의 한 유형으로 볼 수 있다.

본론으로 들어가기 앞서, 그래프에 대해 복습해보자.
그래프(graph)란, 노드(node)와 노드 사이에 연결된 간선(edge)의 정보를 가지고 있는 자료구조를 의미한다.

만약, 알고리즘 문제를 풀다가 서로 다른 개체(혹은 객체(object))가 연결되어 있다는 이야기를 들으면,
가장 먼저 그래프 알고리즘을 떠올려야 한다.

예를들어, 여러 개의 도시가 연결되어 있다.와 같은 내용이 등장하면 그래프 알고리즘을 의심해보자.
더불어 그래프 자료구조 중에서 트리(tree) 자료구조는 다양한 알고리즘에서 사용되므로 꼭 기억하자.
참고로 트리는 전통적인 수학에서는 무방향 그래프로 간주되지만, 컴퓨터공학 분야에서는 보통 방향 그래프로 간주된다.

| 구분                | 그래프(graph)                  | 트리(tree)       |
| ------------------- | ------------------------------ | ---------------- |
| 방향성              | 방향 그래프 혹은 무방향 그래프 | 방향 그래프      |
| 순환성              | 순환 및 비순환                 | 비순환           |
| 루트 노드 존재 여부 | 루트 노드 없음                 | 루트 노드 존재   |
| 노드 간 관계성      | 부모와 자식 관계없음           | 부모와 자식 관계 |
| 모델의 종류         | 네트워크 모델                  | 계층 모델        |

또한, 그래프의 구현 방법은 2가지 방식이 존재하는데, 다음과 같다.

- `인접행렬(adjacency_matrix)` : 2차원 배열을 사용하는 방식
- `인접리스트(adjacency_list)` : 리스트를 사용하는 방식
  - 또, 노드의 개수가 V, 간선의 개수가 E인 그래프를 가정해보면
  - 다음의 표를 떠올릴 수 있다.

여기서 알아두어야 할점은 어떤 문제를 만나든 메모리와 시간을 염두에 두고 알고리즘을 선택해서 구현해야한다.

예를 들어, 최단 경로를 찾아야하는 문제가 나올때

- 노드의 개수가 적다면 floyd_warshall을 사용하고
- 노드와 간선의 개수가 모두 많으면 heap_dijkstra 알고리즘을 이용하면 유리하게 문제를 풀 수 있다.
