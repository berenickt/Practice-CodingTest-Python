"""정렬(sort)
정렬(sort)이란 데이터를 특정한 기준에 따라서 순서대로 나열 하는것을 말한다.
정렬 알고리즘으로 데이터를 정렬하면 다음 장에서 배울 이진 탐색(Binary Search)이 가능해진다.

정렬 알고리즘은 이진 탐색의 전처리 과정이기도 하니 제대로 알고 넘어가자.
정렬알고리즘의 종류는 많지만 삽입정렬, 선택정렬, 퀵 정렬, 계수정렬정도만 배우자.

보통 정렬부터 공부하면 알고리즘의 효율성을 쉽게 이해 할 수 있어, 
알고리즘 개론에서 초반에 정렬 알고리즘을 설명하는 경우가 많다.

이번에는 오름차순 정렬만 배울것인데, 
내림차순 정렬은 오름차순 정렬을 수행 한 뒤에 결과를 뒤집어서(reversed)) 출력하면된다.
이떄, 리스트를 뒤집는 연산(revresed())은 O(N)의 복잡도로 간단히 수행 할 수 있다.
"""

"""선택 정렬(selection_sort)
선택 정렬(selection_sort)은 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 
그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정이다

가장 작은 것을 선택해서 앞으로 보내는 과정을 반복해서 수행하다 보면, 전체 데이터의 정렬이 이루어진다.

수행과정은 다음과 같다.
1. 초기 단계에서 모든 데이터가 정렬되어있지 않으므로, 
    전체 데이터 중 가장 작은 데이터를 선택한다.
2. 첫 번째를 제외하고 이후 데이터 중 
    가장 작은 데이터를 선택해 처리되지 않은 데이터 중 가장 앞에있는 데이터와 바꾼다.
3. 정렬된 데이터를 제외하고 정렬되지 않은 데이터 중
    가장 작은 데이터를 선택하고 처리되지 않은 데이터 중 가장 앞에 있는 데이터와 바꾼다.
4. 가장 작은 데이터를 앞으로 보내는 과정을 모두 반복한 상태의 마지막 데이터는 가만히 두어도 이미 정렬된 상태이다. 
    따라서 정렬을 마칠 수 있다. n-1만큼 반복하면 된다.
"""
array = [10, 1, 3, 4, 2, 9, 7, 8, 0, 5, 6]

for i in range(len(array)):
    min_index = i  # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array  # 스와프
    [min_index], array[i]

print(array)
# 👉🏽 [0, 1, 2, 3, 4, 6, 7, 8, 9]

"""💡 시간복잡도
선택정렬은 N-1번 만큼 가장 작은 수를 찾아 맨 앞으로 보내야 한다.
또한, 매번 가장 작은 수를 찾기 위해서 비교 연산이 필요하다.

구현 방식에 따라 사소한 오차는 있을 수 있지만,
앞쪽의 순서대로 구현했을 경우 연산 횟수는 N + (N-1) + (N-2) + ... + 2로 볼 수 있다.

따라서, 근사치 N x (N + 1) / 2번의 연산을 수행한다고 했을 때,
가장 큰 수를 꺼내면 시간복잡도는 O(N^2)이 된다.

선택정렬은 정렬해야 할 데이터의 개수가 10,000개 이상이면, 
정렬 속도가 급격히 느려지므로 10,000개 이하일때 가급적 사용하도록 하자.
"""
