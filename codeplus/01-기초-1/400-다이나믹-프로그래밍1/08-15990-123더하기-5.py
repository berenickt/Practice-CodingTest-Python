# 💡 1, 2, 3 더하기 5 📚 https://www.acmicpc.net/problem/15990
# 가능한 경우의 수를 저장할 배열 d를 초기화
# d[i][j]는 i를 만들 때 마지막으로 사용한 숫자가 j일 때의 경우의 수를 나타냄
# j = 1, 2, 3은 각각 1, 2, 3을 의미
limit = 100000
d = [[0] * 4 for _ in range(limit + 1)]

# 나머지 연산에 사용할 모듈러 값 mod를 설정
mod = 1000000009

# 바텀업(DP) 방식으로 가능한 경우의 수를 계산
for i in range(1, limit + 1):
    if i - 1 >= 0:
        # 현재 숫자에서 1을 사용하는 경우의 수는 이전 숫자에서 2 또는 3을 사용하는 경우의 수와 같습니다
        d[i][1] = d[i - 1][2] + d[i - 1][3]
        # 초기값: i가 1인 경우, 1만 사용하는 경우의 수는 1
        if i == 1:
            d[i][1] = 1

    if i - 2 >= 0:
        # 현재 숫자에서 2를 사용하는 경우의 수는 이전 숫자에서 1 또는 3을 사용하는 경우의 수와 같습니다
        d[i][2] = d[i - 2][1] + d[i - 2][3]
        # 초기값: i가 2인 경우, 2만 사용하는 경우의 수는 1
        if i == 2:
            d[i][2] = 1

    if i - 3 >= 0:
        # 현재 숫자에서 3을 사용하는 경우의 수는 이전 숫자에서 1 또는 2을 사용하는 경우의 수와 같습니다
        d[i][3] = d[i - 3][1] + d[i - 3][2]
        # 초기값: i가 3인 경우, 3만 사용하는 경우의 수는 1
        if i == 3:
            d[i][3] = 1

    # 나머지 연산을 수행하여 중간 결과값을 제한된 범위로 유지합니다.
    d[i][1] %= mod
    d[i][2] %= mod
    d[i][3] %= mod

# 테스트 케이스의 개수를 입력받습니다.
TEST_CASE = int(input())

# 각 테스트 케이스마다 가능한 경우의 수를 계산하고 출력
for _ in range(TEST_CASE):
    n = int(input())
    # 가능한 경우의 수는 d[n][1], d[n][2], d[n][3]의 합
    # 중간 결과값을 나머지 연산을 통해 제한된 범위로 유지한 후 출력합니다
    print(sum(d[n]) % mod)
