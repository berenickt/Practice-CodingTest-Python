# 1. 소수(Prime Number)

- 정의 : 약수가 1과 자기 자신 밖에 없는 수

소수와 관련된 알고리즘은 2가지가 있습니다.

1. 어떤 수 N이 소수인지 아닌지 판별하는 방법
2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법

---

## 1.1 (1) 방법

- 1부터 100까재의 소수 (1은 소수에 포함되지 않는다)
  - 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31
  - 37, 41, 43, 47, 53, 59, 61, 67, 71, 73
  - 79, 83, 89, 97
- N이 소수가 되려면, 2보다 크거나 같고,
  - N-1보다 작거나 같은 자연수로 나누어 떨어지면 안된다.
- `이유`: N의 약수 중에서 가장 큰 것은 N/2보다 작거나 같기 때문
- `N = a × b`로 나타낼 수 있는데, `a`가 작을수록 `b`는 크다.
- 가능한 `a` 중에서 가장 작은 값은 2이기 때문에, `b`는 `N/2`를 넘지 않는다.

```c
bool prime(int n) {
  if (n < 2) {
    return false;
  }
  for(int i = 2; i<=n/ 2; i++) {
    // 나누어 떨어지면 소수가 아님
    if (n % i == 0) {
      return false;
    }
  }
  // 아니면 소수임
  return true;
}
```

---

## 1.2 (2) 방법

N이 소수가 되려면, 2보다 크거나 같고, 루트N 보다 작거나 같은 자연수로 나누어 떨어지면 안된다.

- 이유: N이 소수가 아니라면, N = a × b로 나타낼 수 있다. (a ≤ b)
- a > b라면 두 수를 바꿔서 항상 a ≤ b로 만들 수 있다.
- 두 수 a와 b의 차이가 가장 작은 경우는 루트 N이다.
- 따라서, 루트 N까지만 검사를 해보면 된다

```c
bool prime(int n) {
  if (n < 2) {
    return false;
  }
  for (int i = 2; i * i <= n; i++) {
    if (n % i == 0) {
      return false;
    }
  }
  return true;
}
```

컴퓨터에서 실수는 근사값을 나타내기 때문에, 루트 N과 같은 경우는 앞 페이지처럼 나타내는 것이 좋다.

- `루트 i ≤ N`은 `i ≤ N * N` 과 같다.
- 어떤 수 N이 소수인지 아닌지 판별하는데 걸리는 시간 복잡도: `O(루트N)`

즉, 1과 자기자신을 제외한 약수가 존재하는지 확인하려면,
자기자신의 제곱근(루트)까지만 확인하면 된다.

> 🔍 e.g. 24의 소수를 에네스트로 체를 이용해 구하면?
>
> ```c
> 1 2 3 4 | 6 8 12 24
> 서로 대칭적으로 짝을 이루기 때문에,
> 한쪽 부분만 소수인지 판별하면 된다.
>
> √24 = 2√6 = 4.89897948...
> ```

어차피 약수들이 대칭적으로 짝을 이루기 때문에,
루트25인 5까지만 나눠떨어지는지 확인하면
해당 숫자가 소수인지 아닌지를 알 수 있다.
