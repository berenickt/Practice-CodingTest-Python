# 1. 다이나믹 프로그래밍 Dynamic

- `큰 문제를 작은 문제로 나눠서 푸는 알고리즘`
- Dynamic Programming의 다이나믹은 **아무 의미가 없다**.
- 이 용어를 처음 사용한 1940년 Richard Bellman은 **멋있어 보여서 사용했다고 한다**

> 💡 cf. 큰 문제를 작은 문제로 푸는 알고리즘은 2가지가 있습니다.
>
> 1. `DP(Dynamic Programming)` : 큰 문제를 나눴을 떄, 작은 문제들이 중복이 가능
>
>    - e.g. 40명을 10명, 30명
>
>    - e.g. 40명을 15명, 25명와 같이 크기를 기준으로 나누는 방법
>
> 2. `분할정복` : 작은 문제들이 중복이 불가능
>
>    - e.g. 가운데를 기주으로 왼쪽, 오른쪽같이 중복이 발생하지 않게 나눔

다음 두 가지 속성을 만족해야 다이나믹 프로그래밍으로 문제를 풀 수 있다

1. `Overlapping Subproblem` : 겹치는 부분(작은) 문제
2. `Optimal Substructure` : 최적 부분 구조 (문제의 정답을 작은문제의 정답을 통해서 구할 수 있다)

---

## 1.1 Overlapping Subproblem

* 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다. (재귀를 사용)
* 문제를 작은 문제로 쪼갤 수 있다.

---

## 1.2 Optimal Substructure

- 문제의 정답을 작은 문제의 정답에서 구할 수 있다
  - e.g. 서울에서 부산을 가는 가장 빠른 길이 대전과 대구를 순서대로 거쳐야 한다면
  - 대전에서 부산을 가는 가장 빠른 길은 대구를 거쳐야 한다.
- Optimal Substructure를 만족한다면, 문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다
- e.g.
  - 10번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
  - 9번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
  - …
  - 5번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
  - 4번째 피보나치 수를 구하면서 구한 4번째 피보나치 수
  - 즉, 4번째 피보나치 수는 항상 같다

---

# 3. Dynamic Programming

- 다이나믹 프로그래밍에서 각 문제는 한 번만 풀어야 한다
- Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같다
- 따라서, 정답을 한 번 구했으면, 정답을 **어딘가에 메모**해놓는다.
- 이런 메모하는 것을 코드의 구현에서는 배열에 저장하는 것으로 할 수 있다.
- 메모를 한다고 해서 영어로 `Memoization`이라고 한다

```cpp
// 피보나치 수를 구하는 함수
int fibonacci(int n) {
  if (n <= 1) {
    return n;
  } else {
    return fibonacci(n-1) + fibonacci(n-1);
  }
}
```

👇 메모이제이션을 추가한 피보나치

```c
int memo[100];
int fibonacci(int n) {
  if (n <= 1) {
    return n;
  } else {
    if (memo[n] > 0) {
      return memo[n];
    }
    memo[n] = fibonacci(n-1) + fibonacci(n-2);
    return memo[n];
  }
}
```

---

# 2. 다이나믹의 구현방식

## 3.1 Top -down (재귀를 이용)

1. 큰 문제를 작은 문제로 나눈다 .
2. 작은 문제를 푼다.
3. 작은 문제를 풀었으니, 이제 큰 문제를 푼다

Top -down 은 재귀 호출을 이용해서 문제를 풀 수 있다

---

## 3.2 Bottom-up (반복문을 이용)

1. 문제를 크기가 작은 문제부터 차례대로 푼다.
2. 문제의 크기를 조금씩 크게 만들면서 문제를 점점 푼다.
3. 작은 문제를 풀면서 왔기 때문에, 큰 문제는 항상 풀 수 있다.
4. 반복하다 보면 가장 큰 문제를 풀 수 있다

---

# 4. 다이나믹 문제 풀이 전략

- 문제에서 구하려고 하는 답을 문장으로 나타낸다.
- e.g. 피보나치 수를 구하는 문제
  - N번째 피보나치 수
  - 이제 그 문장에 나와있는 변수의 개수만큼 메모하는 배열을 만든다.
  - Top-down인 경우에는 재귀 호출의 인자의 개수
  - 문제를 작은 문제로 나누고, 수식을 이용해서 문제를 표현해야 한다
