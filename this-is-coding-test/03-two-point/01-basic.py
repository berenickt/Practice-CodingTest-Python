"""투 포인트(Two Point)
리스트에 순차적으로 접근해야 할 때, 
2개의 점의 위치를 기록하면서 처리하는 알고리즘

e.g. 한 반에 40명이 있을 때, 모든 학생을 번호 순서대로 일렬로 세운 뒤, 
학생들을 순차적으로 지목해야하는 경우를 생각해보자. 

2, 3, 4, 5, 6, 7번 학생을 지목할 때,
우리는 번호로 한명씩 부르기보다는 2번부터 7번 학생! 이라고 부를 수 있다. 

이처럼 순차적으로 접근 할때는 
시작점과 끝점 2개의 점으로 접근할 데이터의 범위를 표현 할 수 있다.

특정한 합을 가지는 부분 연속 수열 찾기 문제를 보자.
양의 정수로만 구성된 리스트가 주어졌을 때, 
그 부분 연속 수열 중 특정한 합을 갖는 수열의 개수를 출력하는 문제이다.

투 포인터 알고리즘의 특징은 `2개의 변수를 이용해 리스트 상의 위치를 기록한다`는 점이다.
그래서, 부분 연속 수열의 시작점과 끝점을 기록한다.

특정한 부분합을 M이라고 할 때 풀이 순서는 다음과 같다.
1. 시작점(start), 끝점(end)이 첫 번째 원소의 인덱스(0)을 가리키자
2. 현재 부분합 M과 같으면 카운트한다.
3. 현재 부분합이 M보다 작으면 end를 1 증가시킨다.
4. 현재 부분합이 M보다 크거나 같으면 start를 1 증가시킨다.
5. 모든 경우를 확인 할 때까지 2번과 4번의 과정을 반복한다.
"""
# 찾고자 하는 데이터의 개수
n = 5
data = [1, 2, 3, 2, 5]

# 찾고자 하는 합의 값
m = 5

# 초기선언
interval_sum = 0
count = 0
end = 0

for start in range(n):
    while interval_sum < m and end < n:
        interval_sum = interval_sum + data[end]
        end = end + 1
    if interval_sum == n:
        count = count + 1
    interval_sum = interval_sum - data[start]

print(count)  # 👉🏽 3

"""
결과적으로 카운트 된 경우의 수는 3이다.
투 포인터 알고리즘의 특징은 구현가능한 방식이 매우 많다는 점이다.

이 문제를 투포인터로 해결 할 수 있는 이유는 
기본적으로 시작점을 오른쪽으로 이동시키면 항상 합이 감소하고,⭐
끝점을 오른쪽으로 이동시키미녀 항상 합이 증가하기 때문이다.⭐

만약, 리스트 내 원소에 음수 데이터가 포함되어있으면,
투 포인터 알고리즘으로 문제를 해결 할 수 없다.
"""
