# 1. 브루트포스(완전탐색)

- Brute (단순히, 순전히), Force(힘)
- 단순무식하게 처음부터 다 대입해보는 것
- 구현 방법
  1. for문이 while문으로 구현
  2. 재귀함수
- 문제 : 프로그래머스의 모의고사, 소수찾기

---

# 2. DFS/BFS (그래프 탐색 알고리즘)

- `DFS(Depth First Search)` = 하나를 깊게(깊이 먼저)
  - DFS는 `stack`을 사용
- `BFS(Breadth First Search)` = 여러 개를 하나씩(너비 먼저)
  - BFS는 `queue`를 사용
- `그래프` : 여러 개체들이 연결되어 있는 자료구조
- `탐색` : 특정 개체를 찾기 위한 알고리즘
- 대표적 문제 유형 :
  1. 경로탐색 유형(최단거리, 시간)
  2. 네트워크 유형(연결)
  3. 조합 유형(모든 조합 만들기)
- 문제 : 프로그래머스, 타겟넘버, 네트워크, 단어변환, 여행경로
- 구현 방법
  - `DFS` : 한 놈만 끝가지 패는 유형이라 재귀함수가 가장 일반적
  - `BFS` : 여러 놈을 한대씩 때리면서 가는 유형이라, Queue나 LinkedList가 가장 일반적
- DFS / BFS 중 어떤 걸 써야할까?
  - 결론부터 말하면 DFS를 더 선호
  - 둘 다 탐색을 하는 알고리즘이기에 어떤걸 써도 정답은 나오고, 자신있고 손에 익은 알고리즘을 쓰면 됩니다.
  - 다만 DFS를 더 선호하는 이유는 검증하기 쉬워서 입니다
  - DFS는 어찌됐든 하나의 조합을 완성해서 정답과 비교하고 또 다른 조합을 만들어 보고 정답과 비교하는 식으로 동작하기 때문에 정답을 비교하는 시점에 내가 기대한 대로 조합이 잘 나왔는지 를 확인해 보기가 빠르고 쉽습니다.
  - 그에 비해 비해 BFS는 한 번에 여러 조합들을 한칸 한칸씩 만들다 보니 조합이 완성되어서 정답과 비교하는 시점에 애가 언제 어떻게 만들어졌는지, 어디서부터 틀려먹은건지를 분석하기가 까다롭습니다.
  - 코딩테스틑 시간싸움이다 보니, 짧은 시간 내 알고리즘을 검증해야 하는데, 이걸 위해서는 DFS가 최적이고, 재귀함수만 익혀두면 코드도 훨씬 간결해져서, 버그가 발생할 가능성이 근본적으로 더 작습니다.
- 하지만 BFS도 필요할 떄가 있습니다.
  - DFS가 한 놈만 패는 알고리즘인데, 그 한놈이 너무 오래 걸리면 시간이 초과될 수 있습니다.
  - 다르게 말하면, DFS는 수행 시간 관점에서는 복불복입니다.
  - 운이 좋으면 첫 번쨰 조합이 최적의 답이지만, 최악의 경우에는 모든 조합을 다 만들어 보면서 시간을 낭비하게 됩니다.
  - 그에 비해 BFS는 모든 경우의 수를 한 걸음씩 나가기 때문에 초반에는 느려보일 수 있지만, 하나의 정답만 찾고나면, 나머지 경우의 수는 정답에서 제외합니다.
  - 쉽게 말해, BFS는 대박날 확률도 적지만, 쪽박 찰 확률도 적습니다.
  - CS적으로 말해보면, 시간복잡도가 낮습니다.
- 코테의 경우
  - 앞쪽에 쉬운 문제로 나왔다면 빠르게 DFS로 푸는 것을 추천하고,
  - 뒤쪽에 어려운 문제로 보이거나, DFS로 풀기 너무 오래 걸릴 거 같으면, BFS로 풉니다.

---

# 3. Hash

- Key: Value형태의 자료구조 (e.g. 전화번호부)
