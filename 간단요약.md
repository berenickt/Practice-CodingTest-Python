# 1. 브루트포스(완전탐색)

- Brute (단순히, 순전히), Force(힘)
- 단순무식하게 처음부터 다 대입해보는 것
- 구현 방법
  1. for문이 while문으로 구현
  2. 재귀함수
- 문제 : 프로그래머스의 모의고사, 소수찾기

---

# 2. DFS/BFS (그래프 탐색 알고리즘)

- `DFS(Depth First Search)` = 하나를 깊게(깊이 먼저)
  - DFS는 `stack`을 사용
- `BFS(Breadth First Search)` = 여러 개를 하나씩(너비 먼저)
  - BFS는 `queue`를 사용
- `그래프` : 여러 개체들이 연결되어 있는 자료구조
- `탐색` : 특정 개체를 찾기 위한 알고리즘
- 대표적 문제 유형 :
  1. 경로탐색 유형(최단거리, 시간)
  2. 네트워크 유형(연결)
  3. 조합 유형(모든 조합 만들기)
- 문제 : 프로그래머스, 타겟넘버, 네트워크, 단어변환, 여행경로
- 구현 방법
  - `DFS` : 한 놈만 끝가지 패는 유형이라 재귀함수가 가장 일반적
  - `BFS` : 여러 놈을 한대씩 때리면서 가는 유형이라, Queue나 LinkedList가 가장 일반적
- DFS / BFS 중 어떤 걸 써야할까?
  - 결론부터 말하면 DFS를 더 선호
  - 둘 다 탐색을 하는 알고리즘이기에 어떤걸 써도 정답은 나오고, 자신있고 손에 익은 알고리즘을 쓰면 됩니다.
  - 다만 DFS를 더 선호하는 이유는 검증하기 쉬워서 입니다
  - DFS는 어찌됐든 하나의 조합을 완성해서 정답과 비교하고 또 다른 조합을 만들어 보고 정답과 비교하는 식으로 동작하기 때문에 정답을 비교하는 시점에 내가 기대한 대로 조합이 잘 나왔는지 를 확인해 보기가 빠르고 쉽습니다.
  - 그에 비해 비해 BFS는 한 번에 여러 조합들을 한칸 한칸씩 만들다 보니 조합이 완성되어서 정답과 비교하는 시점에 애가 언제 어떻게 만들어졌는지, 어디서부터 틀려먹은건지를 분석하기가 까다롭습니다.
  - 코딩테스틑 시간싸움이다 보니, 짧은 시간 내 알고리즘을 검증해야 하는데, 이걸 위해서는 DFS가 최적이고, 재귀함수만 익혀두면 코드도 훨씬 간결해져서, 버그가 발생할 가능성이 근본적으로 더 작습니다.
- 하지만 BFS도 필요할 떄가 있습니다.
  - DFS가 한 놈만 패는 알고리즘인데, 그 한놈이 너무 오래 걸리면 시간이 초과될 수 있습니다.
  - 다르게 말하면, DFS는 수행 시간 관점에서는 복불복입니다.
  - 운이 좋으면 첫 번쨰 조합이 최적의 답이지만, 최악의 경우에는 모든 조합을 다 만들어 보면서 시간을 낭비하게 됩니다.
  - 그에 비해 BFS는 모든 경우의 수를 한 걸음씩 나가기 때문에 초반에는 느려보일 수 있지만, 하나의 정답만 찾고나면, 나머지 경우의 수는 정답에서 제외합니다.
  - 쉽게 말해, BFS는 대박날 확률도 적지만, 쪽박 찰 확률도 적습니다.
  - CS적으로 말해보면, 시간복잡도가 낮습니다.
- 코테의 경우
  - 앞쪽에 쉬운 문제로 나왔다면 빠르게 DFS로 푸는 것을 추천하고,
  - 뒤쪽에 어려운 문제로 보이거나, DFS로 풀기 너무 오래 걸릴 거 같으면, BFS로 풉니다.

---

# 3. Hash

- Key: Value형태의 자료구조 (e.g. 전화번호부)
- 검색창에 이름을 입력하면, 전화번호 결과가 나온다.
  - 여기서 이름 = Key, 전화번호 = Value
  - 무언가 찾기 위한 검색어 = Key, 그 검색어로 나온 결과 = Value
- Hash는 배열과 달리 String 타입이나 다른 어떤 데이터형을 기반으로 자료구조를 접근하고, 데이터를 관리해줌
- Hash에는 여러 특징이 있지만, 코테를 위한 이해할 딱 1가지는 `Hash는 모든 데이터 타입으로 접근이 가능하다`입니다.
- 문제 : 프로그래머스 완주하지 못한 선수
  - Hash를 사용하면 간단하게 해결가능하다
  - `HashMap.put(“A”, true)`로 입력하면, `HashMap[“A”] = true`와 같습니다.
  - 그리고 이 값을 읽어오고 싶을 떄는,
  - `bool fin = hashmap.get(“A”)` 또는 `bool fin = hashmap[“A”]`
- `getOrDefault(“A”, false)` : A가 있다면, A의 Value를 반환, A가 없다면, false를 반환해주는 함수
- `get / put / getOrDefault` 함수 3개를 알면 해시 문제는 대부분 해결 가능
- 어떤 문제에서 Hash를 써야할까?
  - String을 기반으로 정보를 기록하고 관리해야 될 떄 Hash
- 첫 번쨰 예시로 완주하지 못한 선수 문제는 선수이름이 완주여부이고,
  - String이니 Hash를 써야겠다는 생각이 떠올라야 합니다.
  - `String Key : bool Value`라는 HashMap을 구하면 문제를 쉽게 해결할 수 있습니다.
- 두 번쨰로 게시판 사용자 문제의 경우
  - 신고당한 사람을 기준으로, 신고자들의 목록을 관리해야 합니다.
  - 여기서도 신고당한 사람의 이름이 String이니 Hash를 써야겠다고 판단할 수 있고,
  - `String Key`와 `ArrayList<String> Value`를 사용해서 신고자의 목록을 관리하면 됩니다.
- 마지막으로 위장 문제의 경우
  - 옷의 종류에 따라 몇 개의 옵션이 있는지 세야 합니다.
  - 옷의 종류가 정수가 아니라 `얼굴/상의/하의/겉옷`과 같이 String입니다.
  - `String Key : Integer Value`라는 HashMap을 구하면 문제를 쉽게 해결할 수 있습니다
- 결론은 String을 기준으로 정보를 기록하고 관리하려면, 단순 배열을 쓸 수 없으니 Hash를 활용하자.
  - Hash = 전화번호부
  - 대부분 key가 String이다.
  - put / get / getOrDefault 3개 함수만 기억하자

---

# 4. 문자열(String)

## 4.1 문자열 단순 구현 유형

- 별다른 알고리즘이 필요하지 않고, 문제에서 여러 단계에 걸친 동작을 설명해주면, 그대로만 잘 구현하면 되는 문제
- 대표문제 : 카카오 기출의 신규아이디 추천
  - 7단계에 걸쳐서 사용자가 만들려고 하는 아이디를 규치겡 따라 수정하여 새로운 아이디를 추천
  - 대문자를 소문자로 치환하고, 허용하지 않는 문자들을 제거하고 등의 아주 간단한 동작만 수행하면 돼서
  - 이런 문제들은 기본적은 String 관련 함수들만 잘 정리해 뒀다가 시험 전에 복습용으로 1번 쓱 보면 됩니다.
- `equals, length, toUpperCase, toLowerCase`의 기본 4가지 함수
- `indexOf` : 있으면 시작인덱스 위치를 반환, 없으면 -1 반환
  - 문자열 내 다른 문자열이 존재하는지 판단할 떄 사용
- `substring` : string의 일부를 추출할 떄 사용
  - `“Hello”.substring(1, 3) => “el”`
- `replace` : 문자열의 일부를 찾아서 대체하는 함수
  - `“Hello”.replace(“l”, “”) => “He  o”`
- `trim` : 앞뒤 공백을 제거하는 함수
  - `“ Hello ”.trim()) => “Hello”`
- `compareTo` : 두 문자열의 ASCII 순서 비교, 즉 알파벳 순서 비교하는 함수
  - `“a”.compareTo("b")) => (-)`
  - `“a”.compareTo("a")) => 0`
  - `“b”.compareTo("a")) => (+)`
  - 주의할 점은 대문자와 소문자는 각각 다른 아스키 값을 갖기 떄문에 다릅니다.
- 이외에도 `split, contains, charAt, startsWith, endsWith`는 문제풀이하면서 자연스럽게 외웠다면 코테칠 떄, 쓰면 됨
  - 이외라고 적은 함수들은 자주 쓰고 완전히 익혀두지 않으면 시험환경에서 떠올리고 사용하기 힘들다.
  - 위에 필수적인 함수들만 알고있으면, 응용해서 구현이 가능하다.

---

## 4.2 문자열 + 기타 알고리즘 유형

- 첫 번쨰 문자열 단순 구현 + Hash, 정렬, DFS 등의 알고리즘을 접목해야 풀 수 있는 문제
- 대표문제 : 카카오 2022년 신고결과 받기
  - 문자열 parsing => indexOf + substring만 사용해서 풀 수 없고, Hash을 같이 접목해야만 풀 수 있다.
- 두 번쨰 유형의 문제들이 더 많이 출제되는 추세이다.
- 이 유형은 문자열이 첨가된 사실상 알고리즘을 쓸 줄 아는지 물어보는 문제라서,
  - 알고리즘과 자료구조에 대해서 준비할 필요가 있다.

> 💡 문자열 1번 유형의 경우 네카라 1번 문제 문자열로 자주 출제된다.
>
> 문제를 푸는데 어려움이 없고, 관련 함수들을 구글링없이 잘 사용했다면, 충분히 실력을 갖췄다고 판단해도 된다.
> 2번 유형은 다른 알고리즘을 익히는게 더 중요하다.

---

# 5. DP(Dynamic Programing)

- `큰 문제를 작은 문제로 나눠서 푸는 알고리즘`
  - Dynamic Programming의 다이나믹은 **아무 의미가 없다**.
  - 이 용어를 처음 사용한 1940년 Richard Bellman은 **멋있어 보여서 사용했다고 한다**

---

# 6. Greedy(그리디, 탐욕)
