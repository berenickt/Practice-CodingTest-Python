"""📍  BFS(Breadth-First-Search)
BFS 알고리즘은 너비 우선탐색이라는 의미를 가진다. 
쉽게말해, 가까운 노드부터 탐색하는 알고리즘이다.

DFS와 BFS 알고리즘의 주요 차이점은 다음과 같다.
1. DFS: 최대한 멀리있는 노드를 우선으로 탐색하는 방식
2. BFS: 최대한 가까이있는 노드를 우선으로 탐색하는 방식

또한, BFS는 스택(Stack)방식을 사용하는 DFS와 다르게 
선입선출방식인 큐(Queue) 자료구조를 이용하는것이 정석이다.
알고리즘의 동작방식은 다음과 같다.

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 
    방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
"""
from collections import deque


def bfs(graph, start, visited):
    queue = deque([start])
    visited[start] = True

    while queue:
        v = queue.popleft()
        print(v, end=" ")
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True


graph = [[], [2, 3, 8], [1, 7], [1, 4, 5], [3, 5], [3, 4], [7], [2, 6, 8], [1, 7]]

visited = [False] * 9
bfs(graph, 1, visited)
# 👉🏽  2 3 8 7 4 5 6

"""
너비 우선 탐색 알고리즘인 BFS는 큐 자료구조에 기초한다는 점에서 구현이 간단하다.
탐색을 수행함에 있어서 데이터의 개수가 N개인 경우 O(N)의 시간이 소요된다.
일반적인 경우 실제 수행 시간은 DFS보다 좋은 편이라는 점까지만 추가로 기억하자.

앞서 DFS와 BFS를 설명하는데, 전형적인 그래프 그림을 이용했는데, 
1차원 배열이나 2차원 배열 또한 그래프 형태로 생각하면 수월하게 문제를 풀 수 있다.
특히, DFS와 BFS 문제 유형이 그러하다.

코딩 테스트 중 2차원 배열에서의 탐색 문제를 만나면, 
이렇게 그래프 형태로 바꿔서 생각하면 풀이 방법을 조금 더 쉽게 떠올릴 수 있다.
"""
