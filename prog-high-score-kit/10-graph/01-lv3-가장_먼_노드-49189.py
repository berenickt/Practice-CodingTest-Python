# π“ https://school.programmers.co.kr/learn/courses/30/lessons/49189
"""
nκ°μ λ…Έλ“κ°€ μλ” κ·Έλν”„κ°€ μμµλ‹λ‹¤.
κ° λ…Έλ“λ” 1λ¶€ν„° nκΉμ§€ λ²νΈκ°€ μ ν€μμµλ‹λ‹¤.
1λ² λ…Έλ“μ—μ„ κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“μ κ°―μλ¥Ό κµ¬ν•λ ¤κ³  ν•©λ‹λ‹¤.
κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“λ€ μµλ‹¨κ²½λ΅λ΅ μ΄λ™ν–μ„ λ• κ°„μ„ μ κ°μκ°€ κ°€μ¥ λ§μ€ λ…Έλ“λ“¤μ„ μλ―Έν•©λ‹λ‹¤.

λ…Έλ“μ κ°μ n, 
κ°„μ„ μ— λ€ν• μ •λ³΄κ°€ λ‹΄κΈ΄ 2μ°¨μ› λ°°μ—΄ vertexκ°€ λ§¤κ°λ³€μλ΅ μ£Όμ–΄μ§ λ•,
1λ² λ…Έλ“λ΅λ¶€ν„° κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“κ°€ λ‡ κ°μΈμ§€λ¥Ό return

μ…λ ¥ #1
n      : 6
vertex : [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]

μ¶λ ¥ #1
3
"""
from collections import deque


def solution(n, edge):
    answer = 0
    # μ—°κ²°λ λ…Έλ“ μ •λ³΄ κ·Έλν”„
    graph = [[] for _ in range(n + 1)]
    # κ° λ…Έλ“μ μµλ‹¨κ±°λ¦¬ λ¦¬μ¤νΈ
    distance = [-1] * (n + 1)

    # μ—°κ²°λ λ…Έλ“ μ •λ³΄ μ¶”κ°€
    for e in edge:
        graph[e[0]].append(e[1])
        graph[e[1]].append(e[0])

    queue = deque([1])  # BFSλ¥Ό μ„ν• queue, μ¶λ° λ…Έλ“ = 1
    distance[1] = 0  # μ¶λ°λ…Έλ“μ μµλ‹¨κ±°λ¦¬λ¥Ό 0μΌλ΅

    # BFS μν–‰
    while queue:
        now = queue.popleft()  # ν„μ¬ λ…Έλ“

        # ν„μ¬ λ…Έλ“μ—μ„ μ΄λ™ν•  μ μλ” λ¨λ“  λ…Έλ“ ν™•μΈ
        for i in graph[now]:
            if distance[i] == -1:  # μ•„μ§ λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“λ©΄,
                queue.append(i)  # queueμ— μ¶”κ°€
                distance[i] = distance[now] + 1  # μµλ‹¨κ±°λ¦¬ κ°±μ‹ 

    # κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“ κ°μ κµ¬ν•κΈ°
    for d in distance:
        if d == max(distance):
            answer += 1
    return answer


print(solution(6, [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]))
